import json
import os
import unittest
import uuid
from src.comm.types import BaseModel, ErrorObj, RequestType, UnmarshalResult
from src.comm import parser


class Fruit(BaseModel):
    obj_name = "fruit"

    def __init__(self, fruit_id: int = 0, name: str = "", price: float = 0.0, is_good_quality: bool = True):
        super().__init__()
        self.fruit_id = fruit_id
        self.name = name
        self.price = price
        self.is_good_quality = is_good_quality


class TestParser(unittest.TestCase):
    """
    TestParser is a unit test class for testing the functionality of the parser.Parser class.
    Methods:
        __init__(self, *args, **kwargs):
            Initializes the TestParser instance and sets up the path to the JSON fixture file.
        test_init(self):
            Tests the initialization of the parser.Parser class.
            Ensures that the parser is correctly initialized with the expected default values 
            and configurations.
        test_marshal(self):
            Reads a JSON schema from a file, initializes a Parser object with the schema,
            and then marshalls a sample data dictionary into bytes.
            Verifies that the generated bytes match the expected byte sequence.
    """

    def __init__(self, *args, **kwargs):
        super(TestParser, self).__init__(*args, **kwargs)
        self.text_fixture_interface_path = os.path.join(os.path.dirname(
            os.path.abspath(__file__)), 'fixtures', 'interface.json')
        self.text_fixture_services_path = os.path.join(os.path.dirname(
            os.path.abspath(__file__)), 'fixtures', 'services.json')

    def test_init(self):
        """
        Test the initialization of the parser.

        This test ensures that the parser is correctly initialized with the expected
        default values and configurations.
        """
        interface_schema = None
        services_schema = None
        with open(self.text_fixture_interface_path, "r", encoding="utf-8") as f:
            interface_schema = json.load(f)
        with open(self.text_fixture_services_path, "r", encoding="utf-8") as f:
            services_schema = json.load(f)
        p = parser.Parser(interface_schema, services_schema)
        self.assertEqual(p.data, {
            "fruit": {
                "name": "fruit",
                "fields": [
                    ("fruit_id", "int"),
                    ("name", "str"),
                    ("price", "float"),
                    ("is_good_quality", "bool")
                ]
            }
        })

    def test_marshal_object(self):
        """
        Test the marshalling of an object using the parser.
        This test reads a schema from a JSON file, initializes a parser with the schema,
        creates a Fruit object, and marshals it using the parser. It then verifies that
        the generated bytes match the expected byte sequence.
        The expected byte sequence is composed of:
        - The request ID in bytes
        - The fruit ID as a 32-bit (4-byte) integer
        - The length of the fruit name as a 16-bit (2-byte) integer
        - The fruit name as a UTF-8 encoded string
        - The price as a single precision IEEE 754 (4-byte) float
        Asserts:
            The generated bytes from the marshalling process match the expected byte sequence.
        """

        interface_schema = None
        services_schema = None
        with open(self.text_fixture_interface_path, "r", encoding="utf-8") as f:
            interface_schema = json.load(f)
        with open(self.text_fixture_services_path, "r", encoding="utf-8") as f:
            services_schema = json.load(f)
        p = parser.Parser(interface_schema, services_schema)

        data = Fruit(1, "apple", 1.0, True)
        request_id = uuid.uuid4()
        service_id = 1
        generated_bytes = p.marshall(
            request_id, service_id, RequestType.REQUEST, data)
        expected_bytes = request_id.bytes + service_id.to_bytes(
            2, byteorder='big') + b'\x00' + b'\x00\x00\x00\x01' + b'\x00\x05' + b'apple' + b'\x3f\x80\x00\x00' + b'\x01'
        self.assertEqual(generated_bytes, expected_bytes)

    def test_unmarshal(self):
        """
        Tests the unmarshalling functionality of the parser.Parser class.

        This test reads a JSON schema from a file, initializes a Parser object with the schema,
        and then unmarshalls a byte sequence into a data dictionary. It verifies that the generated
        data dictionary matches the expected output.

        Steps:
        1. Reads the JSON schema from the file specified by `self.text_fixture_path`.
        2. Initializes a `parser.Parser` object with the loaded schema.
        3. Defines a sample byte sequence representing a fruit.
        4. Generates a unique request ID using `uuid.uuid4()`.
        5. Unmarshalls the byte sequence into a data dictionary using the `unmarshall` method of the
        `Parser` object.
        6. Asserts that the generated data dictionary matches the expected output.
        """
        interface_schema = None
        services_schema = None
        with open(self.text_fixture_interface_path, "r", encoding="utf-8") as f:
            interface_schema = json.load(f)
        with open(self.text_fixture_services_path, "r", encoding="utf-8") as f:
            services_schema = json.load(f)
        p = parser.Parser(interface_schema, services_schema)

        data = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01' + \
            b'\x00\x01' + b'\x01' + b'\x00\x00\x00\x01' + \
            b'\x00\x05' + b'apple' + b'\x3f\x80\x00\x00' + b'\x01'
        request_id = uuid.UUID('00000000-0000-0000-0000-000000000001')
        generated_data: UnmarshalResult = p.unmarshall(data)
        self.assertEqual(generated_data, UnmarshalResult(
            obj=Fruit(1, "apple", 1.0, True), request_id=request_id, service_id=1, request_type=RequestType.RESPONSE
        ))

    def test_marshal_error(self):
        """
        Test the marshalling of an error object using the parser.

        This test reads a schema from a JSON file, initializes a parser with the schema,
        creates an ErrorObj object, and marshals it using the parser. It then verifies that
        the generated bytes match the expected byte sequence.
        The expected byte sequence is composed of:
        - The request ID in bytes
        - The service ID as a 16-bit (2-byte) integer
        - The request type as a single byte
        - The error message as a UTF-8 encoded string
        Asserts:
            The generated bytes from the marshalling process match the expected byte sequence.
        """

        interface_schema = None
        services_schema = None
        with open(self.text_fixture_interface_path, "r", encoding="utf-8") as f:
            interface_schema = json.load(f)
        with open(self.text_fixture_services_path, "r", encoding="utf-8") as f:
            services_schema = json.load(f)
        p = parser.Parser(interface_schema, services_schema)

        data = ErrorObj("Error message")
        request_id = uuid.uuid4()
        service_id = 1
        generated_bytes = p.marshall(
            request_id, service_id, RequestType.ERROR,  data)
        expected_bytes = request_id.bytes + service_id.to_bytes(
            2, byteorder='big') + b'\x02' + b'Error message'
        self.assertEqual(generated_bytes, expected_bytes)
    
    def test_unmarshal_error(self):
        """
        Tests the unmarshalling functionality of the parser.Parser class for an error object.

        This test reads a JSON schema from a file, initializes a Parser object with the schema,
        and then unmarshalls a byte sequence into a data dictionary. It verifies that the generated
        data dictionary matches the expected output.

        Steps:
        1. Reads the JSON schema from the file specified by `self.text_fixture_path`.
        2. Initializes a `parser.Parser` object with the loaded schema.
        3. Defines a sample byte sequence representing an error object.
        4. Generates a unique request ID using `uuid.uuid4()`.
        5. Unmarshalls the byte sequence into a data dictionary using the `unmarshall` method of the
        `Parser` object.
        6. Asserts that the generated data dictionary matches the expected output.
        """
        interface_schema = None
        services_schema = None
        with open(self.text_fixture_interface_path, "r", encoding="utf-8") as f:
            interface_schema = json.load(f)
        with open(self.text_fixture_services_path, "r", encoding="utf-8") as f:
            services_schema = json.load(f)
        p = parser.Parser(interface_schema, services_schema)

        data = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01' + \
            b'\x00\x01' + b'\x02' + b'Error message'
        request_id = uuid.UUID('00000000-0000-0000-0000-000000000001')
        generated_data: UnmarshalResult = p.unmarshall(data)
        self.assertEqual(generated_data, UnmarshalResult(
            obj=ErrorObj("Error message"), request_id=request_id, service_id=1, request_type=RequestType.ERROR
        ))