import json
import os
import unittest
import uuid
from src.comm import parser


class TestParser(unittest.TestCase):
    """
    TestParser is a unit test class for testing the functionality of the parser.Parser class.
    Methods:
        __init__(self, *args, **kwargs):
            Initializes the TestParser instance and sets up the path to the JSON fixture file.
        test_init(self):
            Tests the initialization of the parser.Parser class.
            Ensures that the parser is correctly initialized with the expected default values 
            and configurations.
        test_marshal(self):
            Reads a JSON schema from a file, initializes a Parser object with the schema,
            and then marshalls a sample data dictionary into bytes.
            Verifies that the generated bytes match the expected byte sequence.
    """

    def __init__(self, *args, **kwargs):
        super(TestParser, self).__init__(*args, **kwargs)
        self.text_fixture_path = os.path.join(os.path.dirname(
            os.path.abspath(__file__)), 'fixtures', 'interface_fruit.json')

    def test_init(self):
        """
        Test the initialization of the parser.

        This test ensures that the parser is correctly initialized with the expected
        default values and configurations.
        """
        schema = None
        with open(self.text_fixture_path, "r", encoding="utf-8") as f:
            schema = json.load(f)
        p = parser.Parser(schema)
        self.assertEqual(p.data, {
            "fruit": {
                "name": "fruit",
                "fields": [
                    ("fruit_id", "int"),
                    ("name", "str"),
                    ("price", "float")
                ]
            }
        })

    def test_marshal(self):
        """
        Tests the parsing functionality of the parser.Parser class.

        This test reads a JSON schema from a file, initializes a Parser object with the schema,
        and then marshalls a sample data dictionary into bytes. It verifies that the generated
        bytes match the expected byte sequence.

        Steps:
        1. Reads the JSON schema from the file specified by `self.text_fixture_path`.
        2. Initializes a `parser.Parser` object with the loaded schema.
        3. Defines a sample data dictionary representing a fruit.
        4. Generates a unique request ID using `uuid.uuid4()`.
        5. Marshalls the sample data into bytes using the `marshall` method of the `Parser` object.
        6. Asserts that the generated bytes match the expected byte sequence.

        Expected byte sequence format:
        - Request ID bytes
        - Fixed byte sequence: b'\x00\x00\x00\x01'
        - Length-prefixed name (e.g., b'\x00\x05' + b'apple')
        - Price in IEEE 754 floating-point format (e.g., b'\x3f\x80\x00\x00' for 1.0)
        """
        schema = None
        with open(self.text_fixture_path, "r", encoding="utf-8") as f:
            schema = json.load(f)
        p = parser.Parser(schema)
        data = {
            "fruit_id": 1,
            "name": "apple",
            "price": 1.0
        }
        request_id = uuid.uuid4()
        generated_bytes = p.marshall("fruit", data, request_id)
        self.assertEqual(generated_bytes, request_id.bytes + b'\x00\x00\x00\x01' +
                         b'\x00\x05' + b'apple' + b'\x3f\x80\x00\x00')

    def test_marshal_object(self):
        """
        Test the marshalling of an object using the parser.
        This test reads a schema from a JSON file, initializes a parser with the schema,
        creates a Fruit object, and marshals it using the parser. It then verifies that
        the generated bytes match the expected byte sequence.
        The expected byte sequence is composed of:
        - The request ID in bytes
        - The fruit ID as a 32-bit (4-byte) integer
        - The length of the fruit name as a 16-bit (2-byte) integer
        - The fruit name as a UTF-8 encoded string
        - The price as a single precision IEEE 754 (4-byte) float
        Asserts:
            The generated bytes from the marshalling process match the expected byte sequence.
        """

        schema = None
        with open(self.text_fixture_path, "r", encoding="utf-8") as f:
            schema = json.load(f)
        p = parser.Parser(schema)

        # pylint: disable=missing-class-docstring
        class Fruit:
            def __init__(self, fruit_id, name, price):
                self.fruit_id = fruit_id
                self.name = name
                self.price = price

            def __getitem__(self, key):
                return getattr(self, key)

        data = Fruit(1, "apple", 1.0)
        request_id = uuid.uuid4()
        generated_bytes = p.marshall("fruit", data, request_id)
        self.assertEqual(generated_bytes, request_id.bytes + b'\x00\x00\x00\x01' +
                         b'\x00\x05' + b'apple' + b'\x3f\x80\x00\x00')

    def test_marshal_object_error(self):
        """
        Test that the `marshall` method of the `Parser` class raises a TypeError
        when attempting to marshal an object that is not subscriptable.
        This test reads a schema from a fixture file, initializes a `Parser` object
        with the schema, and creates an instance of the `Fruit` class. It then
        attempts to marshal the `Fruit` object using the `marshall` method and
        asserts that a TypeError is raised. Additionally, it checks that the error
        message contains the phrase "'Fruit' object is not subscriptable".
        Raises:
            TypeError: If the `marshall` method is called with an object that is
                       not subscriptable.
        """

        schema = None
        with open(self.text_fixture_path, "r", encoding="utf-8") as f:
            schema = json.load(f)
        p = parser.Parser(schema)

        # pylint: disable=missing-class-docstring
        class Fruit:
            def __init__(self, fruit_id, name, price):
                self.fruit_id = fruit_id
                self.name = name
                self.price = price

        data = Fruit(1, "apple", 1.0)
        request_id = uuid.uuid4()

        # Assert that calling p.marshall with an object raises a TypeError
        with self.assertRaises(TypeError) as context:
            p.marshall("fruit", data, request_id)

        # Optional: Check if the error message contains "not subscriptable"
        self.assertIn("'Fruit' object is not subscriptable",
                      str(context.exception))

    def test_unmarshal(self):
        """
        Tests the unmarshalling functionality of the parser.Parser class.

        This test reads a JSON schema from a file, initializes a Parser object with the schema,
        and then unmarshalls a byte sequence into a data dictionary. It verifies that the generated
        data dictionary matches the expected output.

        Steps:
        1. Reads the JSON schema from the file specified by `self.text_fixture_path`.
        2. Initializes a `parser.Parser` object with the loaded schema.
        3. Defines a sample byte sequence representing a fruit.
        4. Generates a unique request ID using `uuid.uuid4()`.
        5. Unmarshalls the byte sequence into a data dictionary using the `unmarshall` method of the 
        `Parser` object.
        6. Asserts that the generated data dictionary matches the expected output.

        Expected data dictionary:
        {
            "fruit_id": 1,
            "name": "apple",
            "price": 1.0,
            "request_id": request_id
        }
        """
        schema = None
        with open(self.text_fixture_path, "r", encoding="utf-8") as f:
            schema = json.load(f)
        p = parser.Parser(schema)
        data = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01' + \
            b'\x00\x00\x00\x01' + b'\x00\x05' + b'apple' + b'\x3f\x80\x00\x00'
        request_id = uuid.UUID('00000000-0000-0000-0000-000000000001')
        generated_data = p.unmarshall(data, "fruit")
        self.assertEqual(generated_data, {
            "fruit_id": 1,
            "name": "apple",
            "price": 1.0,
            "request_id": request_id
        })
