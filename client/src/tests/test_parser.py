import json
import os
import unittest
import uuid
from src.comm.object import BaseModel
from src.comm import parser


class TestParser(unittest.TestCase):
    """
    TestParser is a unit test class for testing the functionality of the parser.Parser class.
    Methods:
        __init__(self, *args, **kwargs):
            Initializes the TestParser instance and sets up the path to the JSON fixture file.
        test_init(self):
            Tests the initialization of the parser.Parser class.
            Ensures that the parser is correctly initialized with the expected default values 
            and configurations.
        test_marshal(self):
            Reads a JSON schema from a file, initializes a Parser object with the schema,
            and then marshalls a sample data dictionary into bytes.
            Verifies that the generated bytes match the expected byte sequence.
    """

    def __init__(self, *args, **kwargs):
        super(TestParser, self).__init__(*args, **kwargs)
        self.text_fixture_interface_path = os.path.join(os.path.dirname(
            os.path.abspath(__file__)), 'fixtures', 'interface.json')
        self.text_fixture_services_path = os.path.join(os.path.dirname(
            os.path.abspath(__file__)), 'fixtures', 'services.json')

    def test_init(self):
        """
        Test the initialization of the parser.

        This test ensures that the parser is correctly initialized with the expected
        default values and configurations.
        """
        interface_schema = None
        services_schema = None
        with open(self.text_fixture_interface_path, "r", encoding="utf-8") as f:
            interface_schema = json.load(f)
        with open(self.text_fixture_services_path, "r", encoding="utf-8") as f:
            services_schema = json.load(f)
        p = parser.Parser(interface_schema, services_schema)
        self.assertEqual(p.data, {
            "fruit": {
                "name": "fruit",
                "fields": [
                    ("fruit_id", "int"),
                    ("name", "str"),
                    ("price", "float"),
                    ("is_good_quality", "bool")
                ]
            }
        })

    def test_marshal_object(self):
        """
        Test the marshalling of an object using the parser.
        This test reads a schema from a JSON file, initializes a parser with the schema,
        creates a Fruit object, and marshals it using the parser. It then verifies that
        the generated bytes match the expected byte sequence.
        The expected byte sequence is composed of:
        - The request ID in bytes
        - The fruit ID as a 32-bit (4-byte) integer
        - The length of the fruit name as a 16-bit (2-byte) integer
        - The fruit name as a UTF-8 encoded string
        - The price as a single precision IEEE 754 (4-byte) float
        Asserts:
            The generated bytes from the marshalling process match the expected byte sequence.
        """

        interface_schema = None
        services_schema = None
        with open(self.text_fixture_interface_path, "r", encoding="utf-8") as f:
            interface_schema = json.load(f)
        with open(self.text_fixture_services_path, "r", encoding="utf-8") as f:
            services_schema = json.load(f)
        p = parser.Parser(interface_schema, services_schema)

        # pylint: disable=missing-class-docstring
        class Fruit(BaseModel):
            obj_name = "fruit"

            def __init__(self, fruit_id: int = 0, name: str = "", price: float = 0.0, is_good_quality: bool = True):
                super().__init__()
                self.fruit_id = fruit_id
                self.name = name
                self.price = price
                self.is_good_quality = is_good_quality

        data = Fruit(1, "apple", 1.0, True)
        request_id = uuid.uuid4()
        service_id = 1
        generated_bytes = p.marshall(request_id, service_id, True, data)
        expected_bytes = request_id.bytes + service_id.to_bytes(
            2, byteorder='big') + b'\x00' + b'\x00\x00\x00\x01' + b'\x00\x05' + b'apple' + b'\x3f\x80\x00\x00' + b'\x01'
        self.assertEqual(generated_bytes, expected_bytes)

    def test_unmarshal(self):
        """
        Tests the unmarshalling functionality of the parser.Parser class.

        This test reads a JSON schema from a file, initializes a Parser object with the schema,
        and then unmarshalls a byte sequence into a data dictionary. It verifies that the generated
        data dictionary matches the expected output.

        Steps:
        1. Reads the JSON schema from the file specified by `self.text_fixture_path`.
        2. Initializes a `parser.Parser` object with the loaded schema.
        3. Defines a sample byte sequence representing a fruit.
        4. Generates a unique request ID using `uuid.uuid4()`.
        5. Unmarshalls the byte sequence into a data dictionary using the `unmarshall` method of the
        `Parser` object.
        6. Asserts that the generated data dictionary matches the expected output.
        """
        interface_schema = None
        services_schema = None
        with open(self.text_fixture_interface_path, "r", encoding="utf-8") as f:
            interface_schema = json.load(f)
        with open(self.text_fixture_services_path, "r", encoding="utf-8") as f:
            services_schema = json.load(f)
        p = parser.Parser(interface_schema, services_schema)

        data = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01' + \
            b'\x00\x01' + b'\x01' + b'\x00\x00\x00\x01' + \
            b'\x00\x05' + b'apple' + b'\x3f\x80\x00\x00' + b'\x01'
        request_id = uuid.UUID('00000000-0000-0000-0000-000000000001')
        generated_data = p.unmarshall(data)
        self.assertEqual(generated_data, {
            "request_id": request_id,
            "service_id": 1,
            "is_request": False,
            "fruit_id": 1,
            "name": "apple",
            "price": 1.0,
            "is_good_quality": True
        })
